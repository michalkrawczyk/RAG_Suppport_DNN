"""Search tool for module_map.json generated by generate_module_map.py.

Usage examples:
    python search_module_map.py DatasetCheck --type class
    python search_module_map.py process_dataframe --type method --package RAG_supporters
    python search_module_map.py "augmentation" --no-methods --no-functions
    python search_module_map.py split --parent agents --json
"""

from __future__ import annotations

import argparse
import json
import sys
from dataclasses import dataclass, field
from pathlib import Path
from typing import Any

# ---------------------------------------------------------------------------
# Data model
# ---------------------------------------------------------------------------

_SEARCH_TYPES = ("all", "module", "class", "method", "function", "usage", "param")


@dataclass
class MatchResult:
    """A single search hit."""

    path: str
    kind: str  # 'module' | 'class' | 'method' | 'function'
    symbol: str  # the matched symbol name (or empty for module-level matches)
    parent_symbol: str = ""  # class name when kind=='method'
    docstring: str | None = None
    extra: dict[str, Any] = field(default_factory=dict)


# ---------------------------------------------------------------------------
# Loading
# ---------------------------------------------------------------------------


def load_map(map_path: Path) -> list[dict]:
    """Load module_map.json from *map_path*."""
    if not map_path.exists():
        print(f"[ERROR] Module map not found: {map_path}", file=sys.stderr)
        sys.exit(1)
    with map_path.open(encoding="utf-8") as fh:
        data = json.load(fh)
    if not isinstance(data, list):
        print("[ERROR] module_map.json must be a JSON array.", file=sys.stderr)
        sys.exit(1)
    return data


# ---------------------------------------------------------------------------
# Matching
# ---------------------------------------------------------------------------


def _matches(text: str | None, query: str, exact: bool = False) -> bool:
    """Case-insensitive matching (substring or exact).

    Parameters
    ----------
    text:
        The text to search in.
    query:
        The search query (already lowercased).
    exact:
        If True, perform exact match; otherwise substring match.
    """
    if text is None:
        return False
    text_lower = text.lower()
    if exact:
        return text_lower == query
    return query in text_lower


def _match_record(
    record: dict,
    query: str,
    search_type: str,
    exact: bool = False,
) -> list[MatchResult]:
    """Return all MatchResults from *record* matching *query* and *search_type*.

    Parameters
    ----------
    record:
        A module record from module_map.json.
    query:
        The search query (already lowercased).
    search_type:
        Type of search to perform.
    exact:
        If True, perform exact match; otherwise substring match.
    """
    results: list[MatchResult] = []
    path = record.get("path", "")

    # -- module level -------------------------------------------------------
    if search_type in ("all", "module"):
        hit_module = _matches(record.get("module"), query, exact)
        hit_file = _matches(record.get("file"), query, exact)
        hit_doc = _matches(record.get("module_docstring"), query, exact)
        if hit_module or hit_file or hit_doc:
            results.append(
                MatchResult(
                    path=path,
                    kind="module",
                    symbol=record.get("module", ""),
                    docstring=record.get("module_docstring"),
                )
            )

    # -- classes ------------------------------------------------------------
    if search_type in ("all", "class"):
        for cls_name, cls_info in record.get("classes", {}).items():
            if not isinstance(cls_info, dict):
                continue
            cls_doc = cls_info.get("docstring")
            if _matches(cls_name, query, exact) or _matches(cls_doc, query, exact):
                results.append(
                    MatchResult(
                        path=path,
                        kind="class",
                        symbol=cls_name,
                        docstring=cls_doc,
                        extra={"methods": cls_info.get("methods", {})},
                    )
                )

    # -- methods ------------------------------------------------------------
    if search_type in ("all", "method"):
        for cls_name, cls_info in record.get("classes", {}).items():
            if not isinstance(cls_info, dict):
                continue
            for method_name, method_info in cls_info.get("methods", {}).items():
                # Support both new dict format and legacy str|None
                if isinstance(method_info, dict):
                    method_doc = method_info.get("docstring")
                    method_line = method_info.get("line")
                else:
                    method_doc = method_info
                    method_line = None
                if _matches(method_name, query, exact) or _matches(method_doc, query, exact):
                    results.append(
                        MatchResult(
                            path=path,
                            kind="method",
                            symbol=method_name,
                            parent_symbol=cls_name,
                            docstring=method_doc,
                            extra={"line": method_line},
                        )
                    )

    # -- module-level functions ---------------------------------------------
    if search_type in ("all", "function"):
        for fn_name, fn_info in record.get("functions", {}).items():
            # Support both new dict format and legacy str|None
            if isinstance(fn_info, dict):
                fn_doc = fn_info.get("docstring")
                fn_line = fn_info.get("line")
            else:
                fn_doc = fn_info
                fn_line = None
            if _matches(fn_name, query, exact) or _matches(fn_doc, query, exact):
                results.append(
                    MatchResult(
                        path=path,
                        kind="function",
                        symbol=fn_name,
                        docstring=fn_doc,
                        extra={"line": fn_line},
                    )
                )

    # -- call-site usages ---------------------------------------------------
    if search_type in ("usage", "all"):
        for call in record.get("calls", []):
            if _matches(call.get("name"), query, exact):
                results.append(
                    MatchResult(
                        path=path,
                        kind="usage",
                        symbol=call["name"],
                        parent_symbol=call.get("receiver") or "",
                        extra={"line": call.get("line")},
                    )
                )

    # -- parameter names / annotations --------------------------------------
    if search_type in ("param", "all"):
        # Collect (func_name, signature) pairs from classes and module functions
        func_items: list[tuple[str, dict]] = []
        for cls_name, cls_info in record.get("classes", {}).items():
            if not isinstance(cls_info, dict):
                continue
            for method_name, method_info in cls_info.get("methods", {}).items():
                if isinstance(method_info, dict) and "signature" in method_info:
                    label = f"{cls_name}.{method_name}"
                    func_items.append((label, method_info["signature"]))
        for fn_name, fn_info in record.get("functions", {}).items():
            if isinstance(fn_info, dict) and "signature" in fn_info:
                func_items.append((fn_name, fn_info["signature"]))

        for func_label, sig in func_items:
            for param in sig.get("params", []):
                if _matches(param.get("name"), query, exact) or _matches(
                    param.get("annotation"), query, exact
                ):
                    results.append(
                        MatchResult(
                            path=path,
                            kind="param",
                            symbol=param["name"],
                            parent_symbol=func_label,
                            extra={"annotation": param.get("annotation")},
                        )
                    )

    return results


def search(
    module_map: list[dict],
    query: str,
    search_type: str = "all",
    package_filter: str | None = None,
    parent_filter: str | None = None,
    exact: bool = False,
) -> list[MatchResult]:
    """Search *module_map* for *query*.

    Parameters
    ----------
    module_map:
        Loaded list of module records.
    query:
        Case-insensitive string to look for.
    search_type:
        One of ``'all'``, ``'module'``, ``'class'``, ``'method'``, ``'function'``.
    package_filter:
        If set, only records whose ``package`` field matches (case-insensitive).
    parent_filter:
        If set, only records whose ``parent_module`` field matches (case-insensitive).
    exact:
        If True, perform exact match; otherwise substring match.

    Returns
    -------
    list[MatchResult]
    """
    query = query.lower()
    package_filter = package_filter.lower() if package_filter else None
    parent_filter = parent_filter.lower() if parent_filter else None

    results: list[MatchResult] = []
    for record in module_map:
        if record.get("error"):
            continue
        if package_filter and record.get("package", "").lower() != package_filter:
            continue
        if parent_filter and record.get("parent_module", "").lower() != parent_filter:
            continue
        results.extend(_match_record(record, query, search_type, exact))

    return results


# ---------------------------------------------------------------------------
# Formatting
# ---------------------------------------------------------------------------

_KIND_LABEL = {
    "module": "MODULE",
    "class": "CLASS",
    "method": "METHOD",
    "function": "FUNCTION",
    "usage": "USAGE",
    "param": "PARAM",
}

_INDENT = "  "


def _wrap_doc(doc: str | None, indent: str = _INDENT * 2) -> str:
    if not doc:
        return ""
    first_line = doc.strip().splitlines()[0].strip()
    return f'{indent}"{first_line}"'


def format_results(
    results: list[MatchResult],
    show_docstrings: bool = True,
    show_methods: bool = True,
    show_functions: bool = True,
) -> str:
    """Render search results as a human-readable string."""
    if not results:
        return "No results found."

    # Group by (path, kind) so that multiple hits in the same file/kind are
    # displayed together.
    lines: list[str] = []
    prev_path = None

    for res in results:
        if res.path != prev_path:
            if prev_path is not None:
                lines.append("")
            lines.append(f"[{_KIND_LABEL[res.kind]}] {res.path}")
            prev_path = res.path
        elif lines and not lines[-1].startswith("["):
            pass  # same path, same block — continue

        if res.kind == "module":
            lines.append(f"{_INDENT}{res.symbol}")
            if show_docstrings:
                doc_line = _wrap_doc(res.docstring)
                if doc_line:
                    lines.append(doc_line)

        elif res.kind == "class":
            lines.append(f"{_INDENT}{res.symbol}")
            if show_docstrings:
                doc_line = _wrap_doc(res.docstring)
                if doc_line:
                    lines.append(doc_line)
            if show_methods and res.extra.get("methods"):
                lines.append(f"{_INDENT}Methods:")
                for m_name, m_info in res.extra["methods"].items():
                    # Support new dict format {"docstring": ..., ...} and legacy str|None
                    m_doc = m_info.get("docstring") if isinstance(m_info, dict) else m_info
                    if show_docstrings and m_doc:
                        first_doc = m_doc.strip().splitlines()[0].strip()
                        lines.append(f'{_INDENT * 2}{m_name} — "{first_doc}"')
                    else:
                        lines.append(f"{_INDENT * 2}{m_name}")

        elif res.kind == "method":
            lines.append(f"{_INDENT}{res.parent_symbol}.{res.symbol}")
            if show_docstrings:
                doc_line = _wrap_doc(res.docstring)
                if doc_line:
                    lines.append(doc_line)

        elif res.kind == "function":
            if not show_functions:
                continue
            lines.append(f"{_INDENT}{res.symbol}()")
            if show_docstrings:
                doc_line = _wrap_doc(res.docstring)
                if doc_line:
                    lines.append(doc_line)

        elif res.kind == "usage":
            receiver = res.parent_symbol
            via_part = f"  (via: {receiver})" if receiver else ""
            line_num = res.extra.get("line")
            at_part = f"  @ {res.path}:{line_num}" if line_num else f"  @ {res.path}"
            lines.append(f"{_INDENT}{res.symbol}{via_part}{at_part}")

        elif res.kind == "param":
            annotation = res.extra.get("annotation")
            type_part = f": {annotation}" if annotation else ""
            lines.append(f"{_INDENT}{res.symbol}{type_part}  in {res.parent_symbol}  @ {res.path}")

    return "\n".join(lines)


def format_results_json(results: list[MatchResult]) -> str:
    """Render search results as a JSON string."""
    payload = [
        {
            "path": r.path,
            "kind": r.kind,
            "symbol": r.symbol,
            "parent_symbol": r.parent_symbol or None,
            "docstring": r.docstring,
            "extra": r.extra if r.extra else None,
        }
        for r in results
    ]
    return json.dumps(payload, indent=2, ensure_ascii=False)


# ---------------------------------------------------------------------------
# CLI
# ---------------------------------------------------------------------------


def _build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        prog="search_module_map",
        description="Search module_map.json for classes, methods, functions and modules.",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python search_module_map.py DatasetCheck
  python search_module_map.py process_dataframe --type method
  python search_module_map.py augment --type class --package RAG_supporters
  python search_module_map.py "compare" --parent agents --no-functions
  python search_module_map.py split --json
""",
    )
    parser.add_argument("query", help="Case-insensitive substring to search for.")
    parser.add_argument(
        "--type",
        dest="search_type",
        choices=list(_SEARCH_TYPES),
        default="all",
        help="Restrict search to a specific symbol type (default: all).",
    )
    parser.add_argument(
        "--package",
        default=None,
        metavar="PACKAGE",
        help="Filter by top-level package name, e.g. RAG_supporters.",
    )
    parser.add_argument(
        "--parent",
        default=None,
        metavar="PARENT",
        help="Filter by parent_module (immediate directory), e.g. agents.",
    )
    parser.add_argument(
        "--map",
        default=None,
        metavar="PATH",
        help="Path to module_map.json (default: agent_ignore/module_map.json in project root).",
    )
    parser.add_argument(
        "--no-docstrings",
        action="store_true",
        help="Hide docstrings in the output.",
    )
    parser.add_argument(
        "--no-methods",
        action="store_true",
        help="Hide method listings inside class results.",
    )
    parser.add_argument(
        "--no-functions",
        action="store_true",
        help="Hide module-level function results.",
    )
    parser.add_argument(
        "--exact",
        action="store_true",
        help="Perform exact match instead of substring search.",
    )
    parser.add_argument(
        "--json",
        dest="output_json",
        action="store_true",
        help="Output results as JSON.",
    )
    return parser


def main(argv: list[str] | None = None) -> None:
    """Run the search-module-map CLI."""
    parser = _build_parser()
    args = parser.parse_args(argv)

    # Resolve map path
    if args.map:
        map_path = Path(args.map).expanduser().resolve()
    else:
        map_path = Path(__file__).parent.parent / "agent_ignore" / "module_map.json"

    module_map = load_map(map_path)

    results = search(
        module_map=module_map,
        query=args.query,
        search_type=args.search_type,
        package_filter=args.package,
        parent_filter=args.parent,
        exact=args.exact,
    )

    if args.output_json:
        print(format_results_json(results))
    else:
        print(
            format_results(
                results,
                show_docstrings=not args.no_docstrings,
                show_methods=not args.no_methods,
                show_functions=not args.no_functions,
            )
        )

    # Exit with non-zero code when nothing was found (useful in pipelines)
    sys.exit(0 if results else 1)


if __name__ == "__main__":
    main()
